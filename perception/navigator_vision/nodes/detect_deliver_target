#!/usr/bin/env python
import rospy
from mil_vision_tools import VisionNode, create_object_msg
import numpy as np
import cv2

__author__ = "Kevin Allen"


class DetectDeliverTargetDetector(VisionNode):
    def find_objects(self, img):
        ## convert input image (img) to gray scale
        cv_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        ## blur resulting image
        ## numerical values were chosen arbitrarily after trial and error on sample bag video files
        cv_image = cv2.GaussianBlur(cv_image, (29,29), 0)

        ## apply threshold on resulting image
        ## numerical values were chosen arbitrarily after tiral and error on sample bag video files
        cv_image = cv2.adaptiveThreshold(cv_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 13, 2)

        ## apply Laplace filter on resulting image
        cv_image = cv2.Laplacian(cv_image, cv2.CV_8UC1)

        ## dilate resulting image (i.e. thicken the lines)
        ## numerical values were chosen arbitrarily after tiral and error on sample bag video files
        kernel = np.ones((2, 2), np.uint8)
        cv_image = cv2.dilate(cv_image, kernel, iterations = 3)

        ## create a list of contours stored in variable "cnts"
        _, cnts, _ = cv2.findContours(cv_image.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        """
        the following for loop cycles through all the contours in "cnts" and finds:
            * centroid (cX, cY)
            * area delimited by the contour (area/area_str)
            * length of the contour (perimeter)
            * number of sides (sides/sides_str)
        If the contour has 4 straigh-edge sides and exeeds the area exceeds a certain threshold (AREA_THRESHOLD) the program prints             the following data near the centroid of shape in the video:
            * area (area_str)
            * shape (shape)
            * number of sides of the shape (sides_str)
        """

        found = []
        for num, c in enumerate(cnts, start = 1):
            index = num
            M = cv2.moments(c)

            ## Calculate the centroid
            if M["m00"] != 0:
                cX = int(M["m10"]/M["m00"])
                cY = int(M["m01"]/M["m00"])
            else:
                cX, cY = 0,0
    
            """If the area is greater than some threshold (AREA_THRESHOLD) then calculate the following:
                * length of the contour of the shape (perimeter)
                * number of sides of the shape (sides/sides_str)
                * area of the shape (area_str)
            """ 
            area = cv2.contourArea(c)
            if area > 5000:
                perimeter = cv2.arcLength(c, True)
                sides = cv2.approxPolyDP(c, .04*perimeter, True)
                sides_str = str(len(sides))
                area_str = str(cv2.contourArea(c))

                """ If the number of sides of the shape is 4 then display the following:
                    * area of the shape (area_str)
                    * name of the shape (shape)
                    * number of sides
                    * the contour of the shape
                """
                if len(sides) == 4:
                    shape = "rect/sqr"
                    cv2.putText(img, area_str, (cX, cY), cv2.FONT_HERSHEY_SIMPLEX, .5, (255, 255, 255), 2)
                    cv2.putText(img, shape, (cX, cY-30), cv2.FONT_HERSHEY_SIMPLEX, .5, (255, 255, 255), 2)
                    cv2.putText(img, sides_str, (cX, cY-60), cv2.FONT_HERSHEY_SIMPLEX, .5, (255, 255, 255), 2)
                    cv2.drawContours(img, cnts, num-1, (0, 255, 0), 2)

                    # TODO: only add targets that persist over time
                    # TODO: add as "target_large" or "target_small" depending on which one it is
                    # TODO: base confidence on something, rather than always 1.0
                    found.append(create_object_msg("target_large", contour=cnts[num-1], confidence=1.0))
                    

        test = cv2.resize(img, (900, 600))
        cv2.imshow("Image window", test)
        cv2.waitKey(50)
        return found


if __name__ == "__main__":
    rospy.init_node("vision_node_example")
    node = DetectDeliverTargetDetector()
    rospy.spin()
